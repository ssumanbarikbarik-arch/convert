{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user of the SwiftConvert application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "email": {
          "type": "string",
          "description": "User's email address.",
          "format": "email"
        },
        "firstName": {
          "type": "string",
          "description": "User's first name."
        },
        "lastName": {
          "type": "string",
          "description": "User's last name."
        },
        "isAdmin": {
          "type": "boolean",
          "description": "Indicates if the user has administrator privileges."
        }
      },
      "required": [
        "id",
        "email"
      ]
    },
    "Conversion": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Conversion",
      "type": "object",
      "description": "Represents a file conversion performed by a user.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Conversion entity."
        },
        "userId": {
          "type": "string",
          "description": "Reference to User. (Relationship: User 1:N Conversion)"
        },
        "inputFileName": {
          "type": "string",
          "description": "Name of the input file."
        },
        "outputFileName": {
          "type": "string",
          "description": "Name of the output file."
        },
        "inputFormat": {
          "type": "string",
          "description": "Format of the input file (e.g., JPG, PDF)."
        },
        "outputFormat": {
          "type": "string",
          "description": "Format of the output file (e.g., PDF, JPG)."
        },
        "conversionDate": {
          "type": "string",
          "description": "Date and time of the conversion.",
          "format": "date-time"
        },
        "fileSize": {
          "type": "number",
          "description": "Size of the file in bytes."
        }
      },
      "required": [
        "id",
        "userId",
        "inputFileName",
        "outputFileName",
        "inputFormat",
        "outputFormat",
        "conversionDate"
      ]
    },
    "Tool": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Tool",
      "type": "object",
      "description": "Represents a conversion tool available on the SwiftConvert platform.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Tool entity."
        },
        "name": {
          "type": "string",
          "description": "Name of the tool (e.g., 'JPG to PDF')."
        },
        "description": {
          "type": "string",
          "description": "A brief description of what the tool does."
        },
        "inputFormats": {
          "type": "array",
          "description": "Array of acceptable input formats.",
          "items": {
            "type": "string"
          }
        },
        "outputFormats": {
          "type": "array",
          "description": "Array of acceptable output formats.",
          "items": {
            "type": "string"
          }
        },
        "enabled": {
          "type": "boolean",
          "description": "Indicates whether the tool is currently enabled for use."
        },
        "fileSizeLimit": {
          "type": "number",
          "description": "Maximum allowed file size for this tool, in bytes."
        }
      },
      "required": [
        "id",
        "name",
        "inputFormats",
        "outputFormats",
        "enabled",
        "fileSizeLimit"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous",
      "google.com"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles. Path-based ownership for private user data.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/users/{userId}/conversions/{conversionId}",
        "definition": {
          "entityName": "Conversion",
          "schema": {
            "$ref": "#/backend/entities/Conversion"
          },
          "description": "Stores conversion history for each user. Includes denormalized 'userId' for authorization independence.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user who owns the conversion."
            },
            {
              "name": "conversionId",
              "description": "The unique identifier of the conversion."
            }
          ]
        }
      },
      {
        "path": "/tools/{toolId}",
        "definition": {
          "entityName": "Tool",
          "schema": {
            "$ref": "#/backend/entities/Tool"
          },
          "description": "Stores information about available conversion tools.",
          "params": [
            {
              "name": "toolId",
              "description": "The unique identifier of the tool."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Collection of admin users. Existence of document indicates admin role.",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the admin user."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to adhere to the principles of Authorization Independence, Structural Segregation, and Access Modeling. User data, conversion data, and tool configurations are stored in separate collections with clear ownership and access rules.\n\n*   **Authorization Independence:** The `Conversion` documents denormalize `userId` to allow direct access control without needing to read the `User` document. The `isAdmin` status for global role management will be checked via existence checks against `/roles_admin/{userId}`.\n*   **Structural Segregation:** Different data types (users, conversions, tools, admin roles) are stored in separate collections, enabling homogeneous security postures within each collection.  Private user data is stored under `/users/{userId}`, while global tool data is under `/tools`. This segregation simplifies security rules and prevents unintended data exposure.\n*   **Access Modeling:** Path-based ownership (`/users/{userId}/conversions/{conversionId}`) is used for user-owned conversion data.  A dedicated collection `/roles_admin/{userId}` is used for storing admin roles. This existence-based check eliminates the need to read user documents for authorization.\n*   **QAPs (Rules are not Filters):** The structure supports secure `list` operations by storing conversions under the user's path (`/users/{userId}/conversions/{conversionId}`). This ensures that users can only list their own conversions. Admin status is checked with existence checks against `/roles_admin/{userId}`.\n\nThis structure promotes security, scalability, and debuggability by minimizing hierarchical dependencies, clearly defining access boundaries, and simplifying security rule logic."
  }
}